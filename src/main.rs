mod cmd;
mod conf;
mod ctrl;

use std::{thread, thread::sleep, time::Duration};

use anyhow::Result;
use std::sync::{Arc, Mutex};

use esp_idf_hal::prelude::*;
use esp_idf_hal::timer::*;
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    nvs::EspDefaultNvsPartition,
    wifi::{ClientConfiguration, Configuration as WifiConfiguration, EspWifi},
};
use esp_idf_sys as _;

use esp_idf_svc::mqtt::client::*;

use esp_idf_hal::i2c::{I2cConfig, I2cDriver};

use crate::cmd::KeyCMD;
use crate::cmd::CMD;
use crate::ctrl::FocCtrlInterface;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("")]
    mqtt_addr: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("foc/states")]
    states_topic: &'static str,
    #[default("foc/cmd")]
    cmd_topic: &'static str,
    #[default("foc/error")]
    err_topic: &'static str,
}

fn main() -> Result<()> {
    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    esp_idf_sys::link_patches(); //Needed for esp32-rs
    println!("Entered Main function!");
    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;
    let mut timer = TimerDriver::new(peripherals.timer00, &TimerConfig::new())?;
    timer.enable(true)?;

    let mut wifi_driver = EspWifi::new(peripherals.modem, sys_loop, Some(nvs)).unwrap();

    wifi_driver
        .set_configuration(&WifiConfiguration::Client(ClientConfiguration {
            ssid: app_config.wifi_ssid.into(),
            password: app_config.wifi_psk.into(),
            ..Default::default()
        }))
        .unwrap();

    wifi_driver.start().unwrap();
    wifi_driver.connect().unwrap();
    while !wifi_driver.is_up().unwrap() {
        let config = wifi_driver.get_configuration().unwrap();
        println!("Waiting for station {:?}", config);
        sleep(Duration::from_millis(1000));
    }
    println!("Wifi connected now");

    // Initialize temperature sensor
    let sda = peripherals.pins.gpio6;
    let scl = peripherals.pins.gpio7;
    let i2c = peripherals.i2c0;
    let config = I2cConfig::new().baudrate(100.kHz().into());
    let i2c = I2cDriver::new(i2c, sda, scl, &config)?;

    let mut ctrl = ctrl::FocCtrl::new(i2c, 0x68);

    //let mut delay = esp_idf_hal::delay::Delay::new_default();

    let conf = MqttClientConfiguration {
        client_id: Some("foc-ctrl-ESP32C3"),
        crt_bundle_attach: Some(esp_idf_svc::sys::esp_crt_bundle_attach),
        username: Some(app_config.mqtt_user.into()),
        password: Some(app_config.mqtt_pass.into()),

        ..Default::default()
    };

    println!("Mqtt ready to connect");

    let (mut client, mut connection) = EspMqttClient::new_with_conn(app_config.mqtt_addr, &conf)?;

    // This is not true until you actually create one
    println!("Mqtt awaiting connection");

    let cmd_queue_raw: Vec<KeyCMD> = Vec::new();
    let cmd_queue = Arc::new(Mutex::new(cmd_queue_raw));

    let cmd_queue_clone = Arc::clone(&cmd_queue);
    thread::spawn(move || {
        println!("MQTT Listening for messages");

        while let Some(msg_result) = connection.next() {
            match msg_result {
                Err(e) => println!("MQTT Message ERROR: {}", e),
                Ok(event) => match event {
                    Event::Received(msg) => {
                        let msg_data = msg.data();
                        let key_cmd_res = serde_json::from_slice::<KeyCMD>(msg_data);
                        match key_cmd_res {
                            Ok(key_cmd) => {
                                //println!("MQTT Message: {:?}", cmd);

                                let mut cmd_queue_value = cmd_queue_clone.lock().unwrap();
                                cmd_queue_value.push(key_cmd);
                            }
                            Err(_e) => {
                                println!("Error parsing command: {:?}", msg_data);
                            }
                        }
                    }
                    _ => {}
                },
            }
        }

        println!("MQTT connection loop exit");
    });

    match client.subscribe(app_config.cmd_topic, QoS::AtMostOnce) {
        Ok(_) => {}
        Err(e) => {
            println!("MQTT subscribe error:  {:?}", e);
        }
    }

    match client.publish(
        app_config.err_topic,
        QoS::AtMostOnce,
        false,
        "FocCtrl-ESP32C3 started".as_bytes(),
    ) {
        Ok(_) => {}
        Err(e) => {
            println!("MQTT publish error:  {:?}", e);
        }
    }

    println!("looping");

    let mut conf = conf::Conf::new();
    let mut cmd_map = cmd::CmdMap::new();

    //let mut reconnect_timer:u64 = 1;
    let mut error_msg = String::new();
    let mut serial_us = 0;
    loop {
        sleep(Duration::from_millis(1));
        let now_us = timer.counter().unwrap();
        let run_seconds = now_us / 1e6 as u64;
        let running_string = ctrl::format_seconds(run_seconds);

        let mut cmd_key = String::new();
        let mut cmd = CMD { id: 0, val: 0.0 };
        {
            let mut cmd_queue_value = cmd_queue.lock().unwrap();
            if !cmd_queue_value.is_empty() {
                let key_cmd = cmd_queue_value.remove(0);

                cmd.id = cmd_map.key2id(&key_cmd.key);
                cmd.val = key_cmd.val;

                let has_update = conf.update(key_cmd.clone());

                if cmd.id == 0 && !has_update {
                    println!("Unknown command: {:?}", key_cmd);
                }

                cmd_key = key_cmd.key.clone();
            }
        }

        match ctrl.loop_cmd(cmd) {
            Ok(rx_data) => {
                let mut rx_data = rx_data.clone();
                rx_data.cmd_key = cmd_key;

                if rx_data.cmd_id > 0 && rx_data.cmd_id < 200 {
                    if !conf.is_fire_water {
                        println!("conf: {:?}", rx_data);
                    }

                    if conf.is_mqtt_conf {
                        let conf_json = serde_json::to_string(&rx_data).unwrap();
                        match client.publish(
                            app_config.states_topic,
                            QoS::AtMostOnce,
                            false,
                            conf_json.as_bytes(),
                        ) {
                            Ok(_) => {}
                            Err(e) => {
                                println!("MQTT publish error: {}, {:?}", running_string, e);
                                error_msg =
                                    format!("MQTT publish error: {}, {:?}", running_string, e);
                            }
                        }
                    }
                }
            }
            Err(e) => {
                println!("Error sending command: {:?}", e);
                error_msg = format!("Error sending command: {:?}", e);
                continue;
            }
        }

        // is it time to loop?
        if now_us - serial_us < (conf.loop_ms - 1) * 1000 {
            continue;
        }
        serial_us = now_us;

        let mut motor_states = ctrl::MotorStates {
            motor_id: ctrl.addr,
            ts: 0.0,
            uq: 0.0,
            id: 0.0,
            iq: 0.0,
            velocity: 0.0,
            position: 0.0,
            torque: 0.0,
            iu: 0.0,
            iv: 0.0,
            iw: 0.0,
            debug: 0.0,
        };

        if conf.is_stream_q {
            sleep(Duration::from_micros(conf.i2c_sleep_us));
            match ctrl.read_current() {
                Ok(data) => {
                    motor_states.iu = (data.first * 1e6).round() / 1e3;
                    motor_states.iv = (data.second * 1e6).round() / 1e3;
                    motor_states.iw = (data.third * 1e6).round() / 1e3;
                }
                Err(e) => {
                    println!("Error reading current: {:?}", e);
                    error_msg = format!("Error reading current: {:?}", e);
                    continue;
                }
            }
        }

        if conf.is_stream_states {
            sleep(Duration::from_micros(conf.i2c_sleep_us));
            match ctrl.read_states() {
                Ok(data) => {
                    motor_states.velocity = data.first;
                    motor_states.position = data.second;
                    motor_states.torque = (data.third * 1e6).round() / 1e3;
                }
                Err(e) => {
                    println!("Error reading states: {:?}", e);
                    error_msg = format!("Error reading states: {:?}", e);
                    continue;
                }
            }
        }

        if conf.is_stream_q {
            sleep(Duration::from_micros(conf.i2c_sleep_us));
            match ctrl.read_q() {
                Ok(data) => {
                    motor_states.uq = data.first;
                    motor_states.id = (data.second * 1e6).round() / 1e3;
                    motor_states.iq = (data.third * 1e6).round() / 1e3;
                }
                Err(e) => {
                    println!("Error reading q: {:?}", e);
                    error_msg = format!("Error reading q: {:?}", e);
                    continue;
                }
            }
        }

        if conf.is_stream_time {
            sleep(Duration::from_micros(conf.i2c_sleep_us));
            match ctrl.read_time() {
                Ok(data) => {
                    motor_states.ts = data.first;
                    motor_states.debug = data.third;
                }
                Err(e) => {
                    println!("Error reading time: {:?}", e);
                    error_msg = format!("Error reading time: {:?}", e);
                    continue;
                }
            }
        }

        let mut states_str = String::from("states:");
        if conf.is_stream_q {
            states_str.push_str(
                format!(
                    "{},{},{},",
                    motor_states.uq, motor_states.id, motor_states.iq
                )
                .as_str(),
            )
        }
        if conf.is_stream_states {
            states_str.push_str(
                format!(
                    "{},{},{},",
                    motor_states.position, motor_states.velocity, motor_states.torque
                )
                .as_str(),
            )
        }
        if conf.is_stream_current {
            states_str.push_str(
                format!(
                    "{},{},{},",
                    motor_states.iu, motor_states.iv, motor_states.iw
                )
                .as_str(),
            )
        }
        if conf.is_stream_time {
            states_str.push_str(format!("{},", motor_states.ts).as_str())
        };

        let states_json = serde_json::to_string(&motor_states).unwrap();
        if conf.is_fire_water {
            println!("{}", states_str.trim_end_matches(','));
        } else if conf.is_print_serial {
            println!("{}", states_json);
        }

        if conf.is_send_mqtt {
            match client.publish(
                app_config.states_topic,
                QoS::AtMostOnce,
                false,
                states_json.as_bytes(),
            ) {
                Ok(_) => {}
                Err(e) => {
                    println!("MQTT publish error: {}, {:?}", running_string, e);
                    error_msg = format!("MQTT publish error: {}, {:?}", running_string, e);
                }
            }
        }

        // publish error message
        if error_msg.is_empty() {
            continue;
        }

        match client.publish(
            app_config.err_topic,
            QoS::AtMostOnce,
            false,
            error_msg.as_bytes(),
        ) {
            Ok(_) => error_msg = String::new(),
            Err(e) => {
                println!("MQTT publish error: {}, {:?}", running_string, e);
                continue;
            }
        }
    }
}
